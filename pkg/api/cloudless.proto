syntax = "proto3";

package cloudless.api.v1;

option go_package = "github.com/cloudless/cloudless/pkg/api;api";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

// ============================================================================
// Core Services
// ============================================================================

// CoordinatorService handles control plane operations
service CoordinatorService {
  // Node management
  rpc EnrollNode(EnrollNodeRequest) returns (EnrollNodeResponse);
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
  rpc GetNode(GetNodeRequest) returns (Node);
  rpc ListNodes(ListNodesRequest) returns (ListNodesResponse);
  rpc DrainNode(DrainNodeRequest) returns (google.protobuf.Empty);
  rpc UncordonNode(UncordonNodeRequest) returns (google.protobuf.Empty);

  // Workload management
  rpc CreateWorkload(CreateWorkloadRequest) returns (Workload);
  rpc UpdateWorkload(UpdateWorkloadRequest) returns (Workload);
  rpc DeleteWorkload(DeleteWorkloadRequest) returns (google.protobuf.Empty);
  rpc GetWorkload(GetWorkloadRequest) returns (Workload);
  rpc ListWorkloads(ListWorkloadsRequest) returns (ListWorkloadsResponse);
  rpc ScaleWorkload(ScaleWorkloadRequest) returns (Workload);

  // Scheduling
  rpc Schedule(ScheduleRequest) returns (ScheduleResponse);
  rpc Reschedule(RescheduleRequest) returns (RescheduleResponse);
}

// AgentService handles node-local operations
service AgentService {
  // Container operations
  rpc RunContainer(RunContainerRequest) returns (RunContainerResponse);
  rpc StopContainer(StopContainerRequest) returns (google.protobuf.Empty);
  rpc GetContainerStatus(GetContainerStatusRequest) returns (ContainerStatus);
  rpc StreamLogs(StreamLogsRequest) returns (stream LogEntry);
  rpc ExecCommand(ExecCommandRequest) returns (ExecCommandResponse);

  // Resource reporting
  rpc ReportResources(ReportResourcesRequest) returns (google.protobuf.Empty);
  rpc GetFragments(GetFragmentsRequest) returns (GetFragmentsResponse);
}

// StorageService handles distributed storage operations
service StorageService {
  // Bucket management
  rpc CreateBucket(CreateBucketRequest) returns (Bucket);
  rpc GetBucket(GetBucketRequest) returns (Bucket);
  rpc ListBuckets(ListBucketsRequest) returns (ListBucketsResponse);
  rpc DeleteBucket(DeleteBucketRequest) returns (google.protobuf.Empty);
  rpc UpdateBucket(UpdateBucketRequest) returns (Bucket);

  // Object operations
  rpc PutObject(stream PutObjectRequest) returns (PutObjectResponse);
  rpc GetObject(GetObjectRequest) returns (stream GetObjectResponse);
  rpc HeadObject(HeadObjectRequest) returns (ObjectMetadata);
  rpc ListObjects(ListObjectsRequest) returns (ListObjectsResponse);
  rpc DeleteObject(DeleteObjectRequest) returns (google.protobuf.Empty);
  rpc CopyObject(CopyObjectRequest) returns (ObjectMetadata);

  // Volume management
  rpc CreateVolume(CreateVolumeRequest) returns (Volume);
  rpc GetVolume(GetVolumeRequest) returns (Volume);
  rpc ListVolumes(ListVolumesRequest) returns (ListVolumesResponse);
  rpc DeleteVolume(DeleteVolumeRequest) returns (google.protobuf.Empty);
  rpc AttachVolume(AttachVolumeRequest) returns (google.protobuf.Empty);
  rpc DetachVolume(DetachVolumeRequest) returns (google.protobuf.Empty);

  // Chunk management (internal)
  rpc GetChunkLocations(GetChunkLocationsRequest) returns (GetChunkLocationsResponse);
  rpc ReplicateChunk(ReplicateChunkRequest) returns (google.protobuf.Empty);
}

// NetworkService handles service discovery and load balancing
service NetworkService {
  // Service management
  rpc CreateService(CreateServiceRequest) returns (Service);
  rpc GetService(GetServiceRequest) returns (Service);
  rpc ListServices(ListServicesRequest) returns (ListServicesResponse);
  rpc DeleteService(DeleteServiceRequest) returns (google.protobuf.Empty);
  rpc UpdateService(UpdateServiceRequest) returns (Service);

  // Endpoint management
  rpc RegisterEndpoint(RegisterEndpointRequest) returns (Endpoint);
  rpc DeregisterEndpoint(DeregisterEndpointRequest) returns (google.protobuf.Empty);
  rpc ListEndpoints(ListEndpointsRequest) returns (ListEndpointsResponse);
  rpc UpdateEndpointHealth(UpdateEndpointHealthRequest) returns (google.protobuf.Empty);

  // Load balancer operations
  rpc GetLoadBalancerConfig(GetLoadBalancerConfigRequest) returns (LoadBalancerConfig);
  rpc UpdateLoadBalancerConfig(UpdateLoadBalancerConfigRequest) returns (LoadBalancerConfig);

  // DNS and discovery
  rpc ResolveService(ResolveServiceRequest) returns (ResolveServiceResponse);
  rpc WatchServiceEndpoints(WatchServiceEndpointsRequest) returns (stream ServiceEndpointEvent);
}

// SecretsService handles encrypted secrets management
// Implements envelope encryption with AES-256-GCM and token-based access control
service SecretsService {
  // Secret management
  rpc CreateSecret(CreateSecretRequest) returns (SecretResponse);
  rpc GetSecret(GetSecretRequest) returns (GetSecretResponse);
  rpc UpdateSecret(UpdateSecretRequest) returns (SecretResponse);
  rpc DeleteSecret(DeleteSecretRequest) returns (google.protobuf.Empty);
  rpc ListSecrets(ListSecretsRequest) returns (ListSecretsResponse);

  // Access token management
  rpc GenerateAccessToken(GenerateAccessTokenRequest) returns (GenerateAccessTokenResponse);
  rpc RevokeAccessToken(RevokeAccessTokenRequest) returns (google.protobuf.Empty);
  rpc ValidateAccessToken(ValidateAccessTokenRequest) returns (ValidateAccessTokenResponse);

  // Key management
  rpc RotateMasterKey(RotateMasterKeyRequest) returns (RotateMasterKeyResponse);
  rpc GetMasterKeyInfo(GetMasterKeyInfoRequest) returns (MasterKeyInfo);

  // Audit
  rpc GetSecretAuditLog(GetSecretAuditLogRequest) returns (GetSecretAuditLogResponse);
}

// ============================================================================
// Common Messages
// ============================================================================

// Node represents a device in the cluster
message Node {
  string id = 1;
  string name = 2;
  string region = 3;
  string zone = 4;
  NodeCapabilities capabilities = 5;
  ResourceCapacity capacity = 6;
  ResourceUsage usage = 7;
  NodeStatus status = 8;
  double reliability_score = 9;
  google.protobuf.Timestamp last_seen = 10;
  map<string, string> labels = 11;
  repeated Taint taints = 12;
}

// NodeCapabilities describes what a node can do
message NodeCapabilities {
  repeated string container_runtimes = 1;
  bool supports_gpu = 2;
  bool supports_arm = 3;
  bool supports_x86 = 4;
  repeated string network_features = 5;
  repeated string storage_classes = 6;
}

// ResourceCapacity represents total resources
// CLD-REQ-010: Reports CPU (millicores), RAM (MiB via bytes), storage (GiB via bytes), IOPS class, egress bandwidth (Mbps via bps)
message ResourceCapacity {
  int64 cpu_millicores = 1;
  int64 memory_bytes = 2;
  int64 storage_bytes = 3;
  int64 bandwidth_bps = 4;
  int32 gpu_count = 5;
  string iops_class = 6;  // IOPS class: "low", "medium", "high", "premium", or "unknown"
}

// ResourceUsage represents current resource usage
message ResourceUsage {
  int64 cpu_millicores = 1;
  int64 memory_bytes = 2;
  int64 storage_bytes = 3;
  int64 bandwidth_bps = 4;
  int32 gpu_count = 5;
}

// NodeStatus represents the current state of a node
message NodeStatus {
  enum Phase {
    UNKNOWN = 0;
    ENROLLING = 1;
    READY = 2;
    DRAINING = 3;
    CORDONED = 4;
    OFFLINE = 5;
    FAILED = 6;
  }

  Phase phase = 1;
  string message = 2;
  google.protobuf.Timestamp last_transition = 3;
  repeated NodeCondition conditions = 4;
}

// NodeCondition represents a condition of a node
message NodeCondition {
  string type = 1;  // Ready, MemoryPressure, DiskPressure, NetworkUnavailable
  string status = 2;  // True, False, Unknown
  string reason = 3;
  string message = 4;
  google.protobuf.Timestamp last_transition = 5;
}

// Taint marks a node as having something that workloads must tolerate
message Taint {
  string key = 1;
  string value = 2;
  string effect = 3;  // NoSchedule, PreferNoSchedule, NoExecute
}

// Fragment represents a slice of resources
message Fragment {
  string id = 1;
  string node_id = 2;
  ResourceCapacity resources = 3;
  string workload_id = 4;
  FragmentStatus status = 5;
  google.protobuf.Timestamp created_at = 6;
}

// FragmentStatus represents the state of a fragment
message FragmentStatus {
  enum State {
    UNKNOWN = 0;
    AVAILABLE = 1;
    RESERVED = 2;
    ALLOCATED = 3;
    RELEASING = 4;
  }

  State state = 1;
  string message = 2;
}

// Workload represents a deployed application
message Workload {
  string id = 1;
  string name = 2;
  string namespace = 3;
  WorkloadSpec spec = 4;
  WorkloadStatus status = 5;
  google.protobuf.Timestamp created_at = 6;
  google.protobuf.Timestamp updated_at = 7;
  map<string, string> labels = 8;
  map<string, string> annotations = 9;
}

// WorkloadSpec defines desired workload state
message WorkloadSpec {
  string image = 1;
  repeated string command = 2;
  repeated string args = 3;
  map<string, string> env = 4;
  ResourceRequirements resources = 5;
  int32 replicas = 6;
  PlacementPolicy placement = 7;
  RestartPolicy restart_policy = 8;
  RolloutStrategy rollout = 9;
  repeated Volume volumes = 10;
  repeated Port ports = 11;
  HealthCheck liveness_probe = 12;
  HealthCheck readiness_probe = 13;
  repeated string image_pull_secrets = 14;
}

// ResourceRequirements defines resource needs
message ResourceRequirements {
  ResourceCapacity requests = 1;
  ResourceCapacity limits = 2;
}

// PlacementPolicy controls where workloads run
message PlacementPolicy {
  repeated string regions = 1;
  repeated string zones = 2;
  map<string, string> node_selector = 3;
  repeated Affinity affinity = 4;
  repeated Affinity anti_affinity = 5;
  repeated Toleration tolerations = 6;
  string spread_topology = 7;  // zone, region, node
}

// Affinity rules for placement
message Affinity {
  enum Type {
    NODE = 0;
    WORKLOAD = 1;
  }

  Type type = 1;
  map<string, string> match_labels = 2;
  string topology_key = 3;
  bool required = 4;
}

// Toleration allows workload on tainted nodes
message Toleration {
  string key = 1;
  string value = 2;
  string operator = 3;  // Equal, Exists
  string effect = 4;
}

// RestartPolicy defines restart behavior
message RestartPolicy {
  enum Policy {
    ALWAYS = 0;
    ON_FAILURE = 1;
    NEVER = 2;
  }

  Policy policy = 1;
  int32 max_retries = 2;
  google.protobuf.Duration backoff = 3;
}

// RolloutStrategy controls updates
message RolloutStrategy {
  enum Strategy {
    ROLLING_UPDATE = 0;
    RECREATE = 1;
    BLUE_GREEN = 2;
  }

  Strategy strategy = 1;
  int32 max_surge = 2;
  int32 max_unavailable = 3;
  int32 min_available = 4;  // Minimum replicas that must remain available during updates
  google.protobuf.Duration pause_duration = 5;
}

// Volume represents storage
message Volume {
  string name = 1;
  string source = 2;  // hostPath, emptyDir, configMap, secret
  string mount_path = 3;
  bool read_only = 4;
  map<string, string> options = 5;
}

// Port represents network port
message Port {
  string name = 1;
  int32 container_port = 2;
  int32 host_port = 3;
  string protocol = 4;  // TCP, UDP
}

// HealthCheck defines health probing
message HealthCheck {
  oneof check {
    ExecProbe exec = 1;
    HTTPProbe http = 2;
    TCPProbe tcp = 3;
  }

  google.protobuf.Duration initial_delay = 4;
  google.protobuf.Duration period = 5;
  google.protobuf.Duration timeout = 6;
  int32 success_threshold = 7;
  int32 failure_threshold = 8;
}

message ExecProbe {
  repeated string command = 1;
}

message HTTPProbe {
  string path = 1;
  int32 port = 2;
  string scheme = 3;  // HTTP, HTTPS
  repeated HTTPHeader headers = 4;
}

message HTTPHeader {
  string name = 1;
  string value = 2;
}

message TCPProbe {
  int32 port = 1;
}

// WorkloadStatus represents current workload state
message WorkloadStatus {
  enum Phase {
    UNKNOWN = 0;
    PENDING = 1;
    SCHEDULING = 2;
    RUNNING = 3;
    UPDATING = 4;
    FAILED = 5;
    SUCCEEDED = 6;
    TERMINATING = 7;
  }

  Phase phase = 1;
  string message = 2;
  int32 ready_replicas = 3;
  int32 current_replicas = 4;
  int32 desired_replicas = 5;
  repeated ReplicaStatus replicas = 6;
  google.protobuf.Timestamp last_transition = 7;
}

// ReplicaStatus represents a single replica
message ReplicaStatus {
  string id = 1;
  string node_id = 2;
  string container_id = 3;
  string state = 4;
  google.protobuf.Timestamp started_at = 5;
  int32 restart_count = 6;
}

// ============================================================================
// Request/Response Messages
// ============================================================================

// Node Management
message EnrollNodeRequest {
  string token = 1;
  string node_name = 2;
  string region = 3;
  string zone = 4;
  NodeCapabilities capabilities = 5;
  ResourceCapacity capacity = 6;
  map<string, string> labels = 7;
}

message EnrollNodeResponse {
  string node_id = 1;
  bytes certificate = 2;
  bytes ca_certificate = 3;
  google.protobuf.Duration heartbeat_interval = 4;
}

// CLD-REQ-010: Heartbeat reports both capacity (available resources) and usage (consumed resources)
message HeartbeatRequest {
  string node_id = 1;
  ResourceCapacity capacity = 2;  // Available capacity for scheduling
  ResourceUsage usage = 3;         // Current resource usage
  repeated Fragment fragments = 4;
  repeated ContainerStatus containers = 5;

  // CLD-REQ-032: Health probe status for containers
  repeated ContainerHealth container_health = 6;
}

// CLD-REQ-032: Health probe status for a single container
message ContainerHealth {
  string container_id = 1;

  // Liveness probe status
  bool liveness_healthy = 2;
  int32 liveness_consecutive_failures = 3;
  int64 liveness_last_check_time = 4;

  // Readiness probe status
  bool readiness_healthy = 5;
  int32 readiness_consecutive_failures = 6;
  int64 readiness_last_check_time = 7;
}

message HeartbeatResponse {
  repeated WorkloadAssignment assignments = 1;
  repeated string containers_to_stop = 2;
  google.protobuf.Duration next_heartbeat = 3;
}

message WorkloadAssignment {
  string fragment_id = 1;
  Workload workload = 2;
  string action = 3;  // run, update, stop
}

message GetNodeRequest {
  string node_id = 1;
}

message ListNodesRequest {
  map<string, string> label_selector = 1;
  repeated string regions = 2;
  repeated string zones = 3;
  int32 limit = 4;
  string continue_token = 5;
}

message ListNodesResponse {
  repeated Node nodes = 1;
  string next_token = 2;
}

message DrainNodeRequest {
  string node_id = 1;
  bool graceful = 2;
  google.protobuf.Duration timeout = 3;
}

message UncordonNodeRequest {
  string node_id = 1;
}

// Workload Management
message CreateWorkloadRequest {
  Workload workload = 1;
}

message UpdateWorkloadRequest {
  Workload workload = 1;
  repeated string update_mask = 2;
}

message DeleteWorkloadRequest {
  string workload_id = 1;
  bool graceful = 2;
  google.protobuf.Duration timeout = 3;
}

message GetWorkloadRequest {
  string workload_id = 1;
}

message ListWorkloadsRequest {
  string namespace = 1;
  map<string, string> label_selector = 2;
  int32 limit = 3;
  string continue_token = 4;
}

message ListWorkloadsResponse {
  repeated Workload workloads = 1;
  string next_token = 2;
}

message ScaleWorkloadRequest {
  string workload_id = 1;
  int32 replicas = 2;
}

// Scheduling
message ScheduleRequest {
  Workload workload = 1;
  bool dry_run = 2;
}

message ScheduleResponse {
  repeated ScheduleDecision decisions = 1;
  string reason = 2;
}

message ScheduleDecision {
  string replica_id = 1;
  string node_id = 2;
  string fragment_id = 3;
  double score = 4;
}

message RescheduleRequest {
  string workload_id = 1;
  string reason = 2;
}

message RescheduleResponse {
  repeated ScheduleDecision old_decisions = 1;
  repeated ScheduleDecision new_decisions = 2;
}

// Container Operations
message RunContainerRequest {
  string fragment_id = 1;
  Workload workload = 2;
  string replica_id = 3;
}

message RunContainerResponse {
  string container_id = 1;
  string status = 2;
}

message StopContainerRequest {
  string container_id = 1;
  google.protobuf.Duration grace_period = 2;
}

message GetContainerStatusRequest {
  string container_id = 1;
}

message ContainerStatus {
  string container_id = 1;
  string state = 2;  // created, running, paused, stopped, failed
  string image = 3;
  google.protobuf.Timestamp started_at = 4;
  google.protobuf.Timestamp finished_at = 5;
  int32 exit_code = 6;
  string reason = 7;
  ResourceUsage usage = 8;
}

message StreamLogsRequest {
  string container_id = 1;
  bool follow = 2;
  int32 tail_lines = 3;
  google.protobuf.Timestamp since = 4;
}

message LogEntry {
  google.protobuf.Timestamp timestamp = 1;
  string stream = 2;  // stdout, stderr
  string line = 3;
}

message ExecCommandRequest {
  string container_id = 1;
  repeated string command = 2;
  map<string, string> env = 3;
  string working_dir = 4;
  bool tty = 5;
}

message ExecCommandResponse {
  int32 exit_code = 1;
  bytes stdout = 2;
  bytes stderr = 3;
}

// Resource Reporting
message ReportResourcesRequest {
  string node_id = 1;
  ResourceCapacity capacity = 2;
  ResourceUsage usage = 3;
}

message GetFragmentsRequest {
  string node_id = 1;
}

message GetFragmentsResponse {
  repeated Fragment fragments = 1;
}

// ============================================================================
// Storage Service Messages
// ============================================================================

// Bucket represents a storage bucket
message Bucket {
  string id = 1;
  string name = 2;
  string namespace = 3;
  BucketSpec spec = 4;
  BucketStatus status = 5;
  google.protobuf.Timestamp created_at = 6;
  map<string, string> labels = 7;
}

message BucketSpec {
  int32 replication_factor = 1;
  string storage_class = 2;  // hot, cold, archive
  bool versioning_enabled = 3;
  google.protobuf.Duration retention_period = 4;
  int64 quota_bytes = 5;
}

message BucketStatus {
  int64 object_count = 1;
  int64 total_bytes = 2;
  int64 used_bytes = 3;
}

// Object metadata
message ObjectMetadata {
  string bucket = 1;
  string key = 2;
  int64 size = 3;
  string content_type = 4;
  string checksum = 5;
  google.protobuf.Timestamp created_at = 6;
  google.protobuf.Timestamp modified_at = 7;
  map<string, string> metadata = 8;
  repeated string chunk_ids = 9;
  int32 replication_factor = 10;
}

// Volume represents a persistent volume
message VolumeSpec {
  string name = 1;
  int64 size_bytes = 2;
  string storage_class = 3;
  string access_mode = 4;  // ReadWriteOnce, ReadOnlyMany, ReadWriteMany
  repeated string node_affinity = 5;
}

// Storage requests
message CreateBucketRequest {
  Bucket bucket = 1;
}

message GetBucketRequest {
  string name = 1;
  string namespace = 2;
}

message ListBucketsRequest {
  string namespace = 1;
  int32 limit = 2;
  string continue_token = 3;
}

message ListBucketsResponse {
  repeated Bucket buckets = 1;
  string next_token = 2;
}

message DeleteBucketRequest {
  string name = 1;
  string namespace = 2;
  bool force = 3;
}

message UpdateBucketRequest {
  Bucket bucket = 1;
  repeated string update_mask = 2;
}

message PutObjectRequest {
  oneof data {
    ObjectMetadata metadata = 1;
    bytes chunk = 2;
  }
}

message PutObjectResponse {
  ObjectMetadata metadata = 1;
}

message GetObjectRequest {
  string bucket = 1;
  string key = 2;
  int64 offset = 3;
  int64 length = 4;
}

message GetObjectResponse {
  oneof data {
    ObjectMetadata metadata = 1;
    bytes chunk = 2;
  }
}

message HeadObjectRequest {
  string bucket = 1;
  string key = 2;
}

message ListObjectsRequest {
  string bucket = 1;
  string prefix = 2;
  string delimiter = 3;
  int32 max_keys = 4;
  string continuation_token = 5;
}

message ListObjectsResponse {
  repeated ObjectMetadata objects = 1;
  repeated string common_prefixes = 2;
  string next_continuation_token = 3;
  bool is_truncated = 4;
}

message DeleteObjectRequest {
  string bucket = 1;
  string key = 2;
}

message CopyObjectRequest {
  string source_bucket = 1;
  string source_key = 2;
  string dest_bucket = 3;
  string dest_key = 4;
}

message CreateVolumeRequest {
  Volume volume = 1;
}

message GetVolumeRequest {
  string volume_id = 1;
}

message ListVolumesRequest {
  string namespace = 1;
  map<string, string> label_selector = 2;
  int32 limit = 3;
  string continue_token = 4;
}

message ListVolumesResponse {
  repeated Volume volumes = 1;
  string next_token = 2;
}

message DeleteVolumeRequest {
  string volume_id = 1;
  bool force = 2;
}

message AttachVolumeRequest {
  string volume_id = 1;
  string node_id = 2;
  string workload_id = 3;
}

message DetachVolumeRequest {
  string volume_id = 1;
  string node_id = 2;
}

message GetChunkLocationsRequest {
  string chunk_id = 1;
}

message GetChunkLocationsResponse {
  repeated ChunkLocation locations = 1;
}

message ChunkLocation {
  string chunk_id = 1;
  string node_id = 2;
  string path = 3;
  google.protobuf.Timestamp last_verified = 4;
}

message ReplicateChunkRequest {
  string chunk_id = 1;
  string source_node_id = 2;
  string target_node_id = 3;
}

// ============================================================================
// Network Service Messages
// ============================================================================

// Service represents a network service
message Service {
  string id = 1;
  string name = 2;
  string namespace = 3;
  ServiceSpec spec = 4;
  ServiceStatus status = 5;
  google.protobuf.Timestamp created_at = 6;
  map<string, string> labels = 7;
}

message ServiceSpec {
  string type = 1;  // ClusterIP, LoadBalancer, NodePort
  repeated ServicePort ports = 2;
  map<string, string> selector = 3;  // Label selector for endpoints
  string session_affinity = 4;  // None, ClientIP
  string load_balancer_policy = 5;  // RoundRobin, LeastConn, Weighted
}

message ServicePort {
  string name = 1;
  int32 port = 2;
  int32 target_port = 3;
  string protocol = 4;  // TCP, UDP
}

message ServiceStatus {
  string cluster_ip = 1;
  repeated string external_ips = 2;
  int32 ready_endpoints = 3;
  int32 total_endpoints = 4;
}

// Endpoint represents a service endpoint (backend)
message Endpoint {
  string id = 1;
  string service_id = 2;
  string address = 3;
  int32 port = 4;
  string node_id = 5;
  string workload_id = 6;
  EndpointHealth health = 7;
  int32 weight = 8;
  string zone = 9;
  google.protobuf.Timestamp registered_at = 10;
}

message EndpointHealth {
  string status = 1;  // Healthy, Unhealthy, Unknown
  int32 consecutive_successes = 2;
  int32 consecutive_failures = 3;
  google.protobuf.Timestamp last_check = 4;
  string reason = 5;
}

// Load balancer configuration
message LoadBalancerConfig {
  string service_id = 1;
  string algorithm = 2;  // RoundRobin, LeastConn, Weighted, Locality
  HealthCheckConfig health_check = 3;
  int32 max_connections = 4;
  google.protobuf.Duration timeout = 5;
  bool locality_aware = 6;
}

message HealthCheckConfig {
  enum Type {
    TCP = 0;
    HTTP = 1;
    GRPC = 2;
  }

  Type type = 1;
  string path = 2;
  google.protobuf.Duration interval = 3;
  google.protobuf.Duration timeout = 4;
  int32 healthy_threshold = 5;
  int32 unhealthy_threshold = 6;
}

// Network requests
message CreateServiceRequest {
  Service service = 1;
}

message GetServiceRequest {
  string service_id = 1;
}

message ListServicesRequest {
  string namespace = 1;
  map<string, string> label_selector = 2;
  int32 limit = 3;
  string continue_token = 4;
}

message ListServicesResponse {
  repeated Service services = 1;
  string next_token = 2;
}

message DeleteServiceRequest {
  string service_id = 1;
}

message UpdateServiceRequest {
  Service service = 1;
  repeated string update_mask = 2;
}

message RegisterEndpointRequest {
  Endpoint endpoint = 1;
}

message DeregisterEndpointRequest {
  string endpoint_id = 1;
}

message ListEndpointsRequest {
  string service_id = 1;
  string zone = 2;
  string health_status = 3;
}

message ListEndpointsResponse {
  repeated Endpoint endpoints = 1;
}

message UpdateEndpointHealthRequest {
  string endpoint_id = 1;
  EndpointHealth health = 2;
}

message GetLoadBalancerConfigRequest {
  string service_id = 1;
}

message UpdateLoadBalancerConfigRequest {
  LoadBalancerConfig config = 1;
}

message ResolveServiceRequest {
  string service_name = 1;
  string namespace = 2;
  string caller_zone = 3;  // For locality-aware routing
}

message ResolveServiceResponse {
  repeated Endpoint endpoints = 1;
  string virtual_ip = 2;
}

message WatchServiceEndpointsRequest {
  string service_id = 1;
}

message ServiceEndpointEvent {
  enum EventType {
    ADDED = 0;
    MODIFIED = 1;
    DELETED = 2;
  }

  EventType type = 1;
  Endpoint endpoint = 2;
}

// ============================================================================
// Secrets Service Messages
// ============================================================================

// SecretMetadata represents secret metadata (no sensitive data)
message SecretMetadata {
  string name = 1;
  string namespace = 2;
  uint64 version = 3;
  repeated string audiences = 4;
  int64 ttl_seconds = 5;
  bool immutable = 6;
  google.protobuf.Timestamp created_at = 7;
  google.protobuf.Timestamp updated_at = 8;
  google.protobuf.Timestamp expires_at = 9;
  map<string, string> labels = 10;
  int32 data_key_count = 11;
}

// SecretData contains encrypted secret data
message SecretData {
  // Map of key -> encrypted value
  map<string, bytes> encrypted_data = 1;

  // Envelope encryption metadata
  bytes encrypted_data_key = 2;  // Data key encrypted with master key
  string key_id = 3;              // Master key identifier
  string algorithm = 4;           // AES-256-GCM
  bytes nonce = 5;                // GCM nonce
}

// SecretResponse combines metadata and data
message SecretResponse {
  SecretMetadata metadata = 1;
  SecretData data = 2;
}

// AccessToken represents a short-lived secret access token
message AccessToken {
  string token_id = 1;
  string secret_ref = 2;  // "namespace/name"
  string audience = 3;
  string token = 4;        // JWT token string
  google.protobuf.Timestamp issued_at = 5;
  google.protobuf.Timestamp expires_at = 6;
  int32 uses_remaining = 7;  // -1 for unlimited
  google.protobuf.Timestamp last_used_at = 8;
}

// MasterKeyInfo contains information about the master key (no key material)
message MasterKeyInfo {
  string key_id = 1;
  string algorithm = 2;
  bool active = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp rotated_at = 5;
}

// SecretAuditEntry represents an audit log entry
message SecretAuditEntry {
  google.protobuf.Timestamp timestamp = 1;
  string action = 2;         // Create, Access, Update, Delete, Rotate
  string secret_ref = 3;     // "namespace/name"
  string actor = 4;          // Workload/service that performed action
  bool success = 5;
  string reason = 6;
  string source_ip = 7;
  string token_id = 8;
}

// Secrets requests
message CreateSecretRequest {
  string name = 1;
  string namespace = 2;
  map<string, bytes> data = 3;  // key -> plaintext value (will be encrypted)

  // Options
  repeated string audiences = 4;      // Workloads/services that can access
  int64 ttl_seconds = 5;              // Token TTL (default 15min)
  bool immutable = 6;                 // Cannot be updated after creation
  google.protobuf.Timestamp expires_at = 7;  // Secret expiration
  map<string, string> labels = 8;
}

message GetSecretRequest {
  string name = 1;
  string namespace = 2;
  string access_token = 3;  // Required for authentication
  string audience = 4;      // Caller identity (workload/service)
}

message GetSecretResponse {
  SecretMetadata metadata = 1;
  map<string, bytes> data = 2;  // key -> decrypted plaintext value
}

message UpdateSecretRequest {
  string name = 1;
  string namespace = 2;
  map<string, bytes> data = 3;  // New data (will be encrypted)

  // Update options
  repeated string audiences = 4;  // Update allowed audiences
  repeated string update_mask = 5;  // Fields to update
  bool revoke_existing_tokens = 6;  // Revoke all existing access tokens
}

message DeleteSecretRequest {
  string name = 1;
  string namespace = 2;
  bool revoke_tokens = 3;  // Revoke all access tokens
}

message ListSecretsRequest {
  string namespace = 1;
  map<string, string> label_selector = 2;
  string name_prefix = 3;
  int32 limit = 4;
  string continue_token = 5;
}

message ListSecretsResponse {
  repeated SecretMetadata secrets = 1;  // Metadata only, no sensitive data
  string next_token = 2;
}

message GenerateAccessTokenRequest {
  string name = 1;
  string namespace = 2;
  string audience = 3;           // Workload/service requesting access
  int64 ttl_seconds = 4;         // Token TTL (max 24h)
  int32 max_uses = 5;            // Max number of uses (-1 for unlimited)
}

message GenerateAccessTokenResponse {
  AccessToken token = 1;
}

message RevokeAccessTokenRequest {
  oneof target {
    string token_id = 1;        // Revoke specific token
    string secret_ref = 2;      // Revoke all tokens for secret ("namespace/name")
  }
}

message ValidateAccessTokenRequest {
  string token = 1;
  string secret_ref = 2;  // "namespace/name"
  string audience = 3;
}

message ValidateAccessTokenResponse {
  bool valid = 1;
  string reason = 2;
  google.protobuf.Timestamp expires_at = 3;
  int32 uses_remaining = 4;
}

message RotateMasterKeyRequest {
  bool re_encrypt_all = 1;  // Re-encrypt all secrets with new key
}

message RotateMasterKeyResponse {
  MasterKeyInfo old_key = 1;
  MasterKeyInfo new_key = 2;
  int32 secrets_re_encrypted = 3;
}

message GetMasterKeyInfoRequest {
  string key_id = 1;  // Empty for active key
}

message GetSecretAuditLogRequest {
  string secret_ref = 1;  // "namespace/name" (empty for all)
  google.protobuf.Timestamp start_time = 2;
  google.protobuf.Timestamp end_time = 3;
  int32 limit = 4;
  string continue_token = 5;
}

message GetSecretAuditLogResponse {
  repeated SecretAuditEntry entries = 1;
  string next_token = 2;
}