# Example: Nginx workload with health probes
# This demonstrates CLD-REQ-032: Health probes drive automated restart and traffic gating

apiVersion: cloudless/v1
kind: Workload
metadata:
  name: nginx-web-server
  namespace: default
  labels:
    app: nginx
    tier: frontend
  annotations:
    description: "Nginx web server with liveness and readiness probes"

spec:
  # Container image
  image: nginx:1.25-alpine

  # Resource requirements
  resources:
    requests:
      cpu_millicores: 500        # 0.5 CPU
      memory_bytes: 536870912    # 512 MiB
      storage_bytes: 1073741824  # 1 GiB
    limits:
      cpu_millicores: 1000       # 1 CPU
      memory_bytes: 1073741824   # 1 GiB

  # Number of replicas for high availability
  replicas: 3

  # Placement policy
  placement:
    # Spread across zones for fault tolerance
    spread_topology: zone

    # Prefer nodes with SSD storage
    node_selector:
      storage_class: "ssd"

    # Anti-affinity: Don't place multiple replicas on same node
    anti_affinity:
      - type: WORKLOAD
        match_labels:
          app: nginx
        topology_key: "node"
        required: true

  # Restart policy
  restart_policy:
    policy: ALWAYS
    max_retries: 5
    backoff: 30s

  # Rollout strategy
  rollout:
    strategy: ROLLING_UPDATE
    max_surge: 1
    max_unavailable: 0
    min_available: 2  # Keep at least 2 replicas available during updates

  # Network ports
  ports:
    - name: http
      container_port: 80
      protocol: TCP

  # Liveness probe - Restarts container if failing
  # This probe checks if nginx is responding to HTTP requests
  liveness_probe:
    http:
      path: /
      port: 80
      scheme: HTTP
    initial_delay: 15s    # Wait 15s after container starts before probing
    period: 10s           # Check every 10 seconds
    timeout: 3s           # Timeout after 3 seconds
    failure_threshold: 3  # Restart after 3 consecutive failures
    success_threshold: 1  # Consider healthy after 1 success

  # Readiness probe - Gates traffic to container
  # This probe checks if nginx is ready to serve traffic
  readiness_probe:
    http:
      path: /
      port: 80
      scheme: HTTP
    initial_delay: 5s     # Start checking readiness after 5s
    period: 5s            # Check every 5 seconds
    timeout: 2s           # Timeout after 2 seconds
    failure_threshold: 2  # Mark unready after 2 consecutive failures
    success_threshold: 1  # Mark ready after 1 success

---

# Alternative example: Custom health check endpoint

apiVersion: cloudless/v1
kind: Workload
metadata:
  name: api-server-custom-health
  namespace: default
  labels:
    app: api-server

spec:
  image: my-api:latest

  resources:
    requests:
      cpu_millicores: 1000
      memory_bytes: 2147483648  # 2 GiB

  replicas: 2

  # Custom health check endpoints
  liveness_probe:
    http:
      path: /health/live       # Custom liveness endpoint
      port: 8080
      scheme: HTTP
      headers:
        - name: X-Health-Check
          value: "true"
    initial_delay: 20s
    period: 15s
    timeout: 5s
    failure_threshold: 3
    success_threshold: 1

  readiness_probe:
    http:
      path: /health/ready      # Custom readiness endpoint
      port: 8080
      scheme: HTTP
    initial_delay: 10s
    period: 5s
    timeout: 3s
    failure_threshold: 2
    success_threshold: 1

---

# Example: Database with TCP probe

apiVersion: cloudless/v1
kind: Workload
metadata:
  name: postgres-database
  namespace: database
  labels:
    app: postgres

spec:
  image: postgres:16-alpine

  resources:
    requests:
      cpu_millicores: 2000
      memory_bytes: 4294967296  # 4 GiB
      storage_bytes: 107374182400  # 100 GiB

  replicas: 1  # Database typically single instance

  restart_policy:
    policy: ALWAYS

  # Database port
  ports:
    - name: postgres
      container_port: 5432
      protocol: TCP

  # Environment variables
  env:
    POSTGRES_USER: "cloudless"
    POSTGRES_DB: "cloudless_db"
    # Password from secret (not shown)

  # TCP probe for database
  # Checks if PostgreSQL port is accepting connections
  liveness_probe:
    tcp:
      port: 5432
    initial_delay: 30s     # Database needs time to initialize
    period: 10s
    timeout: 5s
    failure_threshold: 3
    success_threshold: 1

  readiness_probe:
    tcp:
      port: 5432
    initial_delay: 15s
    period: 5s
    timeout: 3s
    failure_threshold: 2
    success_threshold: 1

---

# Example: Worker with exec probe

apiVersion: cloudless/v1
kind: Workload
metadata:
  name: background-worker
  namespace: workers
  labels:
    app: worker

spec:
  image: my-worker:latest

  resources:
    requests:
      cpu_millicores: 500
      memory_bytes: 1073741824  # 1 GiB

  replicas: 5

  restart_policy:
    policy: ON_FAILURE
    max_retries: 10

  # Exec probe runs a command inside the container
  # This checks if the worker process is running
  liveness_probe:
    exec:
      command:
        - /bin/sh
        - -c
        - pgrep -f worker_process || exit 1
    initial_delay: 10s
    period: 30s
    timeout: 5s
    failure_threshold: 2
    success_threshold: 1

  readiness_probe:
    exec:
      command:
        - /bin/sh
        - -c
        - test -f /tmp/worker_ready && pgrep -f worker_process
    initial_delay: 5s
    period: 10s
    timeout: 3s
    failure_threshold: 2
    success_threshold: 1

---

# Health Probe Best Practices (Comments):

# 1. LIVENESS PROBE GUIDELINES:
#    - Use for detecting deadlocks, infinite loops, or crashed processes
#    - Set initial_delay long enough for app startup
#    - Set failure_threshold carefully (too low = restart loops)
#    - Liveness checks should be lightweight (< 100ms)
#    - Example checks:
#      * HTTP: GET /health/live → 200 OK
#      * TCP: Port connectivity
#      * Exec: Process existence check

# 2. READINESS PROBE GUIDELINES:
#    - Use for determining if container can serve traffic
#    - Can be more expensive than liveness (database connectivity, etc.)
#    - Lower initial_delay than liveness (traffic gating needed sooner)
#    - Example checks:
#      * HTTP: GET /health/ready → 200 OK (check dependencies)
#      * TCP: Service port accepting connections
#      * Exec: Validate config loaded, connections established

# 3. PROBE TIMING GUIDELINES:
#    - initial_delay: Allow app startup time
#      * Web servers: 10-20s
#      * Databases: 30-60s
#      * Microservices: 5-15s
#    - period: How often to check
#      * Liveness: 10-30s (less frequent)
#      * Readiness: 5-10s (more frequent for traffic gating)
#    - timeout: Max probe duration
#      * Usually 2-5s
#      * Must be < period
#    - failure_threshold: Consecutive failures before action
#      * Liveness: 3-5 (avoid restart loops)
#      * Readiness: 2-3 (faster traffic gating)

# 4. COMMON PATTERNS:
#    - Separate endpoints for liveness and readiness
#    - Liveness checks local state only
#    - Readiness checks dependencies (database, cache, etc.)
#    - Use exec probes for non-HTTP services
#    - TCP probes for simple connectivity checks

# 5. TROUBLESHOOTING:
#    - Container restarting frequently?
#      → Check liveness probe timing and thresholds
#      → Ensure initial_delay is sufficient
#    - Traffic not reaching container?
#      → Check readiness probe is passing
#      → Verify port and path are correct
#    - Probes timing out?
#      → Increase timeout value
#      → Check probe endpoint performance
